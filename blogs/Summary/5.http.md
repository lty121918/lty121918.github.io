---
title: 知识总结（五）HTTP相关
date: 2022-02-13
tags:
 - HTTP
sidebar: 'auto'
categories:
 - 计算机网络
 - 知识总结
---

>参考文章：
>
>[(建议收藏)前端面试必问的十六条HTTP网络知识体系 (qq.com)](https://mp.weixin.qq.com/s/BMAj0tKXd7E00PHYK_68JA)
>
>[《图解HTTP》读书笔记 (gitee.io)](https://ekzodia_lty.gitee.io/blog/blogs/Network/httptj.html#tcp-ip协议族按层次分为以下四层)
>
>[（转）前端缓存知识 (gitee.io)](https://ekzodia_lty.gitee.io/blog/blogs/About/1.html#前言)

## OSI七层模型

- 应用层（HTTP、SMTP、FTP、DNS）
- 表示层
- 会话层
- 运输层（TCP、UDP）
- 网络层（IP层）
- 链路层
- 物理层

## TCP/IP模型

+ 应用层：FTP文件传输协议、HTTP协议、DNS域名系统
+ 传输层：TCP、UDP
+ 网络层：IP协议

## UDP 与 TCP 的区别是什么？

### UDP

UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。

#### UDP的特点：

- 面向无连接
- 不可靠性
- 高效（头部开销小，只有八个字节）
- 传输方式（一对一，一对多，多对多都支持）

#### UDP的使用场景：

- 直播
- 实时性要求很高的游戏

### TCP

#### TCP头部标识符

- URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
- ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
- SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
- FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。

## 三次握手

最开始客户端处于`CLOSED`状态，服务器处于`LISTEN`状态(随时等待被撩)。

- **第一握手：** 客户端首先发送一段`SYN`报文，包含生成的序列号，这个时候客户端处于`发送后等待`状态。

- **第二次握手：** 服务端收到客户端发送的`SYN`报文后，将序列号`+1`后作为`ACk`应答码返回给客户端，一并返回的包括服务端生成的序列号。这个时候服务端就处于`半连接`状态，服务端也能确认了客户端的`发送能力正常`，自己的`发送能力`、`接收能力`正常，唯独不知道客户端的接收能力是否正常。所以说二次握手并不能满足实际需要。

- **第三次握手：** 客户端接收到服务端返回的`ACK`以及序列号后，将序列号`+1`作为`ACK`码再返回给服务端。这个时候客户端就能确认自己的`发送`、`接收`能力正常，服务端的`发送`、`接收`能力也正常。服务端接收到`ACK`码之后，将之前的半连接转换成全连接，也就完成了握手连接。

  所以，三次握手正好确认双方的`发送`、`接收`能力正常了，再多一次可以嘛？其实也可以的，只是无用，白白浪费了而已，所以三次足以。

  **备注：**三次握手过程中，前两次不可携带数据，第三次握手可以携带数据。因为前两次若能携带数据的话，攻击者会利用这个缺陷发送大量数据给服务端，而故意忽略第三次，从而导致服务端产生大量`半连接`状态会话，同时服务器要耗费更多内存去处理数据，`半连接`多了，达到一定数量后影响`正常连接`，导致丢包等事件发生，故而产生`SYN`攻击。第三次握手是可以携带数据的，因为第三次握手的时候，已经建立了正常连接，互相信任了，这个时候处理数据也无可厚非。

## 四次挥手

- **第一次挥手：** 客户端要断开连接，向服务端发送`FIN`报文，其中会包含客户端生成的序列号。这个时候客户端处于`FIN-WAIT-1`状态，也就是说这个时候客户端处于只能接收、不会再发送的状态。
- **第二次挥手：** 服务端回应客户端状态。这个时候服务端也不在接收来自客户端的数据，处于`CLOSED-WAIT`状态，但是还有未处理完的数据要继续处理。客户端收到服务端反馈后变成`FIN-WAIT2`状态。
- **第三次挥手：** 服务端处理完最后发送的数据后，再想客户端发送`FIN`，自己进入`LAST-ACK`状态。
- **第四次挥手：** 客户端收到服务端发来的`FIN`后，自己变成了`TIME-WAIT`状态，然后发送 `ACK` 给服务端。
  **备注：**第三次挥手后，服务端会间隔一定时间发送报文给客户端，确保客户端收到报文。只有当收到客户端第四次挥手返回的信息，才不会发送。所以第四次挥手后，客户端需要等待足够长的时间(`2MSL`)，也就是报文最大生存时间，来确保没有再收到服务端返回的信息，只要没收到信息，客户端就能确保服务端收到第四次握手信息了，服务端也确保第三次握手也是成功的了。

## http缓存

- 强缓存
- 协商缓存
- 缓存位置

### 1.什么是强缓存、协商缓存

关于什么时候命中`强缓存`，什么时候命中`协商缓存`，主要依赖于`http`返回头信息里的`Cache-Control`返回字段进行控制。

**什么情况下命中强缓存？**以常见的`max-age`为例：若`max-age=5356800`，则意思是说浏览器在首次请求这个文件的时候，可以在本地磁盘中保存这个文件`5356800秒`，从首次加载时间开始以后的这些时间内，若再次请求这个文件，浏览器可以不发起`http`请求，而直接使用缓存中的内容即可，这样不仅节省了服务器负担，也提升网站用户体验。
**什么情况下命中协商缓存？**仍然以常见的`max-age`为例：若`max-age=5356800`，距离第一次请求文件已经过去了`5356800秒`，当用户再次需要这个资源的时候，浏览器就会拿之前这个文件返回的`Etag`以及`Last-Modified`，分别命名为`If-None-Match`和`If-Modified-Since`作为请求参数传给服务端，服务端与现有文件进行匹配，若文件已更新，则返回`200`状态码，同时返回最新文件给客户端。若文件未更新，则返回`304`状态码，告诉客户端缓存有效，可以继续使用。

### 2.缓存位置

关于文件缓存位置，可通过`Chrome`开发面板中，`Network`栏目下每个文件后面有一个`Size`属性查看

- 首次请求，会显示当前文件大小，例如`xxkB`。
- 在网页未关闭之前，再次请求，会从内存中取出文件，显示`(memory cache)`。
- 关闭网页再次请求的时候，若命中强缓存，会从磁盘中取出，显示`(disk cache)`。

### 3.Cache-Control有哪些字段

**public** 公共的。表示任何人都可以缓存，包括浏览器、代理服务器等。
**private** 私有的。表示只允许单个用户缓存，不能作为共享缓存。
**no-cache** 本地可以缓存，但每次都需要与服务端协商，即每次都命中协商缓存。
**no-store** 不适用任何缓存。
**max-age=xxx** 设置缓存最大周期(单位秒)，超过这个相对时间被认为是过期，需要与服务端协商是否还可继续使用。与`Expires`不同，因为它是绝对时间，目前基本上已被废弃，因为若服务器时间与客户端时间相差较大的情况下，会产生一些异常问题。
**s-maxage=xxx** 设置代理服务器缓存文件过期相对时间，客户端会忽略它。
**must-revalidate** 一旦资源过期(比如超过max-age)，在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。
**no-transform** 不得对资源进行转换或转变。
**only-if-cached** 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。

## http状态码

### 状态码的类别

![img](https://gitee.com/ekzodia_lty/blog-image/raw/master/img/image-20220115182031227.png)

### 2XX 成功

200：客户端发来的请求在服务端被正常处理。

204：表示该服务接收的请求已经成功处理，但在返回的响应报文中不含实体的主体部分。一般只在需要从客户端往服务端发送信息，对客户端不需要发送新信息内容的情况下使用。

206：表示客户端进行了范围请求，而服务器成功执行了这部分GET请求。

### 3XX 重定向

> 3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

301：永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。

302：临时重定向。该状态码表示请求的资源已经被分配给了新的URI，希望用户本次能够使用新的URI访问。

303：该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。（明确使用GET方法获得资源，与302有所区别）

304：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX当中，但是和重定向没有关系。

307：临时重定向。该状态码与302有着相同的意义。

### 4XX 客户端错误

400：表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器回向200 OK一样对待该状态码。

401：该状态码发送的请求需要有通过HTTP认证的认证信息。另外若之前已经进行过1次请求，则表示用户认证失败。

403：表示对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权、访问权限等情况都可能是发生403的原因。

404：表示服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说明理由时使用。

### 5XX 服务器错误

500：表示服务器在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。

503：表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

get post区别及应用场景

### GET 和 POST 的区别。

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从**幂等性**的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)
- 从 **TCP** 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

## http 1.0 1.1 2.0

### HTTP1.1 如何解决 HTTP 的队头阻塞问题？

#### 什么是 HTTP 队头阻塞？

从前面的小节可以知道，HTTP 传输是基于`请求-应答`的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的`HTTP队头阻塞`问题。

#### 并发连接

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。

但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

#### 域名分片

一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。

比如 content1.sanyuan.com 、content2.sanyuan.com。

这样一个`sanyuan.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

### HTTP/2 有哪些改进？

- 头部压缩。
- 多路复用。
- 服务器推送。 

## HTTPS

![](https://gitee.com/ekzodia_lty/blog-image/raw/master/img/20220219173255.png)

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

## TLS

SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层，SSL 在 1999 年被 `IETF(互联网工程组)`更名为 TLS ，即传输安全层，直到现在，TLS 一共出现过三个版本，1.1、1.2 和 1.3 ，目前最广泛使用的是 1.2。

TLS 用于两个通信应用程序之间提供保密性和数据完整性。TLS 由**记录协议、握手协议、警告协议、变更密码规范协议、扩展协议**等几个子协议组成，综合使用了**对称加密、非对称加密、身份认证**等许多密码学前沿技术。

TLS 是使用`对称加密`和`非对称加密` 的混合加密方式来实现机密性。